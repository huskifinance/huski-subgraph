// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class IVaultConfig extends ethereum.SmartContract {
  static bind(address: Address): IVaultConfig {
    return new IVaultConfig("IVaultConfig", address);
  }

  acceptDebt(worker: Address): boolean {
    let result = super.call("acceptDebt", "acceptDebt(address):(bool)", [
      ethereum.Value.fromAddress(worker)
    ]);

    return result[0].toBoolean();
  }

  try_acceptDebt(worker: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("acceptDebt", "acceptDebt(address):(bool)", [
      ethereum.Value.fromAddress(worker)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  getFairLaunchAddr(): Address {
    let result = super.call(
      "getFairLaunchAddr",
      "getFairLaunchAddr():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getFairLaunchAddr(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getFairLaunchAddr",
      "getFairLaunchAddr():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getInterestRate(debt: BigInt, floating: BigInt): BigInt {
    let result = super.call(
      "getInterestRate",
      "getInterestRate(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(debt),
        ethereum.Value.fromUnsignedBigInt(floating)
      ]
    );

    return result[0].toBigInt();
  }

  try_getInterestRate(
    debt: BigInt,
    floating: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getInterestRate",
      "getInterestRate(uint256,uint256):(uint256)",
      [
        ethereum.Value.fromUnsignedBigInt(debt),
        ethereum.Value.fromUnsignedBigInt(floating)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getKillBps(): BigInt {
    let result = super.call("getKillBps", "getKillBps():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getKillBps(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getKillBps", "getKillBps():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getReservePoolBps(): BigInt {
    let result = super.call(
      "getReservePoolBps",
      "getReservePoolBps():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getReservePoolBps(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getReservePoolBps",
      "getReservePoolBps():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getWNativeRelayer(): Address {
    let result = super.call(
      "getWNativeRelayer",
      "getWNativeRelayer():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getWNativeRelayer(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getWNativeRelayer",
      "getWNativeRelayer():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getWrappedNativeAddr(): Address {
    let result = super.call(
      "getWrappedNativeAddr",
      "getWrappedNativeAddr():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getWrappedNativeAddr(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getWrappedNativeAddr",
      "getWrappedNativeAddr():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isWorker(worker: Address): boolean {
    let result = super.call("isWorker", "isWorker(address):(bool)", [
      ethereum.Value.fromAddress(worker)
    ]);

    return result[0].toBoolean();
  }

  try_isWorker(worker: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isWorker", "isWorker(address):(bool)", [
      ethereum.Value.fromAddress(worker)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  killFactor(worker: Address, debt: BigInt): BigInt {
    let result = super.call(
      "killFactor",
      "killFactor(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(worker),
        ethereum.Value.fromUnsignedBigInt(debt)
      ]
    );

    return result[0].toBigInt();
  }

  try_killFactor(worker: Address, debt: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "killFactor",
      "killFactor(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(worker),
        ethereum.Value.fromUnsignedBigInt(debt)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  minDebtSize(): BigInt {
    let result = super.call("minDebtSize", "minDebtSize():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minDebtSize(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("minDebtSize", "minDebtSize():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  workFactor(worker: Address, debt: BigInt): BigInt {
    let result = super.call(
      "workFactor",
      "workFactor(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(worker),
        ethereum.Value.fromUnsignedBigInt(debt)
      ]
    );

    return result[0].toBigInt();
  }

  try_workFactor(worker: Address, debt: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "workFactor",
      "workFactor(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(worker),
        ethereum.Value.fromUnsignedBigInt(debt)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}
